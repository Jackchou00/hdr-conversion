{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"HDR Conversion","text":"<p>Important Note: In alpha stage, API may change frequently. Currently, color conversion may be incorrect. This project is still in a very early stage, please submit issues or contact the author directly if you encounter any problems.</p> <p>This project provides Python-based tools for parsing, writing, and converting between various HDR image formats.</p> <p>This library enables research and experimentation with HDR formats:</p> <ul> <li>UltraHDR - JPEG gainmap (MPF + XMP)</li> <li>ISO 21496-1 - Adaptive gainmap standard</li> <li>ISO 22028-5 - Pure PQ/HLG formats</li> <li>Apple HEIC - iOS HDR format</li> <li>iOS HDR Screenshot - iOS screenshot HEIC with tile-based encoding</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Install using <code>uv</code> (recommended):</p> <pre><code>uv add hdr-conversion\n</code></pre> <p>Install using <code>pip</code>:</p> <pre><code>pip install hdr-conversion\n</code></pre> <p>Import the package:</p> <pre><code>import hdrconv\n</code></pre>"},{"location":"#module-overview","title":"Module Overview","text":""},{"location":"#core-types-hdrconvcore","title":"Core Types (<code>hdrconv.core</code>)","text":"<p>Data structures for HDR representation:</p> <ul> <li><code>GainmapImage</code> - Baseline + gainmap + metadata</li> <li><code>GainmapMetadata</code> - ISO 21496-1 parameters</li> <li><code>HDRImage</code> - Linear RGB + metadata</li> <li><code>AppleHeicData</code> - Apple format data</li> </ul>"},{"location":"#conversion-hdrconvconvert","title":"Conversion (<code>hdrconv.convert</code>)","text":"<p>Format transformation algorithms:</p> <ul> <li><code>gainmap_to_hdr()</code> / <code>hdr_to_gainmap()</code></li> <li><code>apple_heic_to_hdr()</code></li> <li><code>convert_color_space()</code></li> <li><code>apply_pq()</code> / <code>inverse_pq()</code></li> </ul>"},{"location":"#io-hdrconvio","title":"I/O (<code>hdrconv.io</code>)","text":"<p>Reading and writing functions:</p> <ul> <li><code>read_21496()</code> / <code>write_21496()</code></li> <li><code>read_ultrahdr()</code> / <code>write_ultrahdr()</code></li> <li><code>read_22028_pq()</code> / <code>write_22028_pq()</code></li> <li><code>read_apple_heic()</code></li> <li><code>read_ios_hdr_screenshot()</code></li> </ul>"},{"location":"#identification-hdrconvidentify","title":"Identification (<code>hdrconv.identify</code>)","text":"<p>Format detection utilities:</p> <p>Check for gainmap presence, only for Apple HEIC</p> <ul> <li><code>has_gain_map()</code> </li> </ul>"},{"location":"#documentation-sections","title":"Documentation Sections","text":"<ul> <li>API Reference - API documentation</li> <li>Examples - Practical use cases</li> </ul>"},{"location":"#use-cases","title":"Use Cases","text":""},{"location":"#research-learning","title":"Research &amp; Learning","text":"<ul> <li>Understand HDR format internals</li> <li>Experiment with conversion algorithms</li> <li>Analyze metadata structures</li> </ul>"},{"location":"#format-conversion","title":"Format Conversion","text":"<ul> <li>Convert UltraHDR to broadcast formats</li> <li>Extract HDR data from Apple HEIC</li> <li>Create gainmaps from linear HDR</li> </ul>"},{"location":"#quality-analysis","title":"Quality Analysis","text":"<ul> <li>Inspect gainmap metadata</li> <li>Compare format implementations</li> <li>Validate color conversions</li> </ul>"},{"location":"#limitations","title":"Limitations","text":"<p>\u26a0\ufe0f Important:</p> <ul> <li>Not production-ready</li> <li>Color conversion may be inaccurate</li> <li>Edge cases may not be handled</li> <li>Performance not optimized</li> <li>API stability not guaranteed</li> </ul>"},{"location":"#license","title":"License","text":"<p>MIT License. See LICENSE for details.</p>"},{"location":"examples/","title":"Examples","text":"<p>See GitHub repository for complete example code: hdr-conversion/examples</p>"},{"location":"examples/#iso-21496-1-gainmap-pq-avif","title":"ISO 21496-1 Gainmap \u2192 PQ AVIF","text":"<p>Convert ISO 21496-1 Gainmap JPEG to PQ AVIF format:</p> <pre><code>import hdrconv.io as io\nimport hdrconv.convert as convert\n\n# Read Gainmap file\ngainmap_data = io.read_21496(\"iso21496.jpg\")\n\n# Convert to linear HDR\nhdr = convert.gainmap_to_hdr(\n    gainmap_data,\n    baseline_color_space=\"p3\",\n    alt_color_space=\"bt2020\",\n    target_color_space=\"bt2020\",\n)\n\n# Apply PQ transfer function\npq_encoded = convert.apply_pq(hdr[\"data\"])\n\n# Write PQ AVIF\npq_data = {\n    \"data\": pq_encoded,\n    \"color_space\": \"bt2020\",\n    \"transfer_function\": \"pq\",\n    \"icc_profile\": None,\n}\nio.write_22028_pq(pq_data, \"output.avif\")\n</code></pre>"},{"location":"examples/#apple-heic-pq-avif","title":"Apple HEIC \u2192 PQ AVIF","text":"<p>Convert Apple HEIC HDR format to standard PQ AVIF:</p> <pre><code>import hdrconv.io as io\nimport hdrconv.convert as convert\n\n# Read Apple HEIC\nheic_data = io.read_apple_heic(\"photo.HEIC\")\n\n# Convert to linear HDR (Display P3)\nhdr = convert.apple_heic_to_hdr(heic_data)\n\n# Convert color space P3 \u2192 BT.2020\nhdr_bt2020 = convert.convert_color_space(\n    hdr[\"data\"], \n    source_space=\"p3\", \n    target_space=\"bt2020\"\n)\n\n# Apply PQ and write\npq_encoded = convert.apply_pq(hdr_bt2020)\npq_data = {\n    \"data\": pq_encoded,\n    \"color_space\": \"bt2020\",\n    \"transfer_function\": \"pq\",\n    \"icc_profile\": None,\n}\nio.write_22028_pq(pq_data, \"output.avif\")\n</code></pre>"},{"location":"examples/#apple-heic-gainmap-jpeg-iso-21496-1-ultrahdr","title":"Apple HEIC \u2192 Gainmap JPEG (ISO 21496-1 + UltraHDR)","text":"<p>Generate both ISO 21496-1 and UltraHDR JPEGs from Apple HEIC:</p> <pre><code>import hdrconv.io as io\nimport hdrconv.convert as convert\n\n# Read Apple HEIC\nheic_data = io.read_apple_heic(\"photo.HEIC\")\n\n# Convert to linear HDR (Display P3)\nhdr = convert.apple_heic_to_hdr(heic_data)\n\n# Load Display P3 ICC\nwith open(\"icc/Display P3.icc\", \"rb\") as f:\n    p3_icc = f.read()\n\n# Generate Gainmap (baseline in P3)\ngainmap_data = convert.hdr_to_gainmap(\n    hdr,\n    baseline=None,\n    color_space=\"p3\",\n    icc_profile=p3_icc,\n    gamma=1.0,\n)\n\n# Write ISO 21496-1 and UltraHDR\nio.write_21496(gainmap_data, \"output_iso21496.jpg\")\nio.write_ultrahdr(gainmap_data, \"output_uhdr.jpg\")\n</code></pre>"},{"location":"examples/#pq-avif-iso-21496-1-gainmap","title":"PQ AVIF \u2192 ISO 21496-1 Gainmap","text":"<p>Convert PQ AVIF to ISO 21496-1 Gainmap format:</p> <pre><code>import hdrconv.io as io\nimport hdrconv.convert as convert\n\n# Read PQ AVIF\npq_data = io.read_22028_pq(\"image.avif\")\n\n# Convert PQ to linear HDR\nlinear_hdr = convert.inverse_pq(pq_data[\"data\"])\n\nhdr = {\n    \"data\": linear_hdr,\n    \"color_space\": \"bt2020\",\n    \"transfer_function\": \"linear\",\n}\n\n# Generate Gainmap (auto-create SDR baseline)\ngainmap_data = convert.hdr_to_gainmap(\n    hdr,\n    baseline=None,  # Auto-generate\n    color_space=\"p3\",\n    gamma=1.0,\n)\n\n# Write ISO 21496-1\nio.write_21496(gainmap_data, \"output_gainmap.jpg\")\n</code></pre>"},{"location":"examples/#ios-hdr-screenshot-ultrahdr","title":"iOS HDR Screenshot \u2192 UltraHDR","text":"<p>Convert iOS HDR screenshots (HEIC with tile-based HEVC) to UltraHDR:</p> <p>External Dependencies</p> <p>Requires <code>MP4Box</code> (GPAC) and <code>ffmpeg</code>. Install on macOS: <code>brew install gpac ffmpeg</code></p> <pre><code>from hdrconv.io import read_ios_hdr_screenshot, write_ultrahdr\n\n# Read iOS HDR screenshot\ngainmap_image = read_ios_hdr_screenshot(\"screenshot.HEIC\")\n\n# Load and embed Display P3 ICC profile\nwith open(\"icc/Display P3.icc\", \"rb\") as f:\n    p3_icc = f.read()\n\ngainmap_image[\"baseline_icc\"] = p3_icc\ngainmap_image[\"gainmap_icc\"] = p3_icc\n\n# Write directly as UltraHDR (no conversion needed)\nwrite_ultrahdr(gainmap_image, \"output_uhdr.jpg\")\n</code></pre>"},{"location":"api/","title":"API Reference","text":"<p>This section contains the complete API documentation for the hdrconv package.</p>"},{"location":"api/#module-overview","title":"Module Overview","text":"<ul> <li>Core Types - Data structures and type definitions</li> <li>Conversion Functions - HDR format conversion algorithms</li> <li>I/O Operations - Reading and writing HDR formats</li> <li>Format Identification - Format detection utilities</li> </ul>"},{"location":"api/convert/","title":"Conversion","text":""},{"location":"api/convert/#hdrconv.convert","title":"<code>hdrconv.convert</code>","text":"<p>HDR conversion algorithms.</p> <p>This module provides functions for converting between HDR formats and applying color space and transfer function transformations:</p> <ul> <li>Gainmap conversion: <code>gainmap_to_hdr</code>, <code>hdr_to_gainmap</code></li> <li>Apple HEIC conversion: <code>apple_heic_to_hdr</code></li> <li>Color space conversion: <code>convert_color_space</code></li> <li>Transfer functions: <code>apply_pq</code>, <code>inverse_pq</code></li> </ul>"},{"location":"api/convert/#hdrconv.convert.apple_heic_to_hdr","title":"<code>apple_heic_to_hdr(data)</code>","text":"<p>Convert Apple HEIC gain map data to linear HDR.</p> <p>Applies Apple's proprietary gain map formula to reconstruct the HDR image from the SDR base and single-channel gain map.</p> The reconstruction formula is <p>hdr_rgb = sdr_rgb * (1.0 + (headroom - 1.0) * gainmap)</p> <p>Where all values are in linear light space.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>AppleHeicData</code> <p>AppleHeicData dict containing: - <code>base</code>: SDR image, uint8, shape (H, W, 3), Display P3. - <code>gainmap</code>: Gain map, uint8, shape (H, W, 1). - <code>headroom</code>: Peak luminance multiplier.</p> required <p>Returns:</p> Type Description <code>HDRImage</code> <p>HDRImage dict with the following keys:</p> <code>HDRImage</code> <ul> <li><code>data</code> (np.ndarray): Linear HDR array, float32, shape (H, W, 3).</li> </ul> <code>HDRImage</code> <ul> <li><code>color_space</code> (str): 'p3' (Display P3, Apple's default).</li> </ul> <code>HDRImage</code> <ul> <li><code>transfer_function</code> (str): 'linear'.</li> </ul> <code>HDRImage</code> <ul> <li><code>icc_profile</code> (bytes | None): None.</li> </ul> Note <p>The gain map is upscaled from 1/4 resolution using bilinear interpolation. Both base image (sRGB transfer) and gain map (Rec. 709 transfer) are linearized before applying the formula.</p> See Also <ul> <li><code>read_apple_heic</code>: Read AppleHeicData from HEIC file.</li> <li><code>convert_color_space</code>: Convert output to BT.2020 if needed.</li> </ul> Source code in <code>src/hdrconv/convert/apple.py</code> <pre><code>def apple_heic_to_hdr(data: AppleHeicData) -&gt; HDRImage:\n    \"\"\"Convert Apple HEIC gain map data to linear HDR.\n\n    Applies Apple's proprietary gain map formula to reconstruct the HDR image\n    from the SDR base and single-channel gain map.\n\n    The reconstruction formula is:\n        hdr_rgb = sdr_rgb * (1.0 + (headroom - 1.0) * gainmap)\n\n    Where all values are in linear light space.\n\n    Args:\n        data: AppleHeicData dict containing:\n            - `base`: SDR image, uint8, shape (H, W, 3), Display P3.\n            - `gainmap`: Gain map, uint8, shape (H, W, 1).\n            - `headroom`: Peak luminance multiplier.\n\n    Returns:\n        HDRImage dict with the following keys:\n        - ``data`` (np.ndarray): Linear HDR array, float32, shape (H, W, 3).\n        - ``color_space`` (str): 'p3' (Display P3, Apple's default).\n        - ``transfer_function`` (str): 'linear'.\n        - ``icc_profile`` (bytes | None): None.\n\n    Note:\n        The gain map is upscaled from 1/4 resolution using bilinear interpolation.\n        Both base image (sRGB transfer) and gain map (Rec. 709 transfer) are\n        linearized before applying the formula.\n\n    See Also:\n        - `read_apple_heic`: Read AppleHeicData from HEIC file.\n        - `convert_color_space`: Convert output to BT.2020 if needed.\n    \"\"\"\n\n    def apply_gain_map(\n        base_image: np.ndarray, gain_map: np.ndarray, headroom: float\n    ) -&gt; np.ndarray:\n        if base_image is None or gain_map is None:\n            raise ValueError(\"Both base_image and gain_map must be provided.\")\n\n        gain_map_resized = np.array(\n            Image.fromarray(gain_map).resize(\n                (base_image.shape[1], base_image.shape[0]), Image.BILINEAR\n            )\n        )\n\n        gain_map_norm = gain_map_resized.astype(np.float32) / 255.0\n        gain_map_linear = np.where(\n            gain_map_norm &lt;= 0.08145,\n            gain_map_norm / 4.5,\n            np.power((gain_map_norm + 0.099) / 1.099, 1 / 0.45),\n        )\n        gain_map_linear = np.clip(gain_map_linear, 0.0, 1.0)\n\n        base_image_norm = base_image.astype(np.float32) / 255.0\n        base_image_linear = np.where(\n            base_image_norm &lt;= 0.04045,\n            base_image_norm / 12.92,\n            np.power((base_image_norm + 0.055) / 1.055, 2.4),\n        )\n        base_image_linear = np.clip(base_image_linear, 0.0, 1.0)\n\n        hdr_image_linear = base_image_linear * (\n            1.0 + (headroom - 1.0) * gain_map_linear[..., np.newaxis]\n        )\n        hdr_image_linear = np.clip(hdr_image_linear, 0.0, None)\n        return hdr_image_linear\n\n    hdr_linear = apply_gain_map(data[\"base\"], data[\"gainmap\"], data[\"headroom\"])\n\n    return HDRImage(\n        data=hdr_linear,\n        color_space=\"p3\",  # Apple uses Display P3\n        transfer_function=\"linear\",\n        icc_profile=None,\n    )\n</code></pre>"},{"location":"api/convert/#hdrconv.convert.convert_color_space","title":"<code>convert_color_space(image, source_space, target_space, clip=False)</code>","text":"<p>Convert image between color spaces.</p> <p>Transforms RGB values from one color space to another using chromatic adaptation and matrix transformations. Input must be in linear light.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>ndarray</code> <p>Linear RGB image data, float32, shape (H, W, 3). Values should be in linear light (not gamma-encoded).</p> required <code>source_space</code> <code>str</code> <p>Source color space identifier. Options: 'bt709' (Rec. 709), 'p3' (Display P3), 'bt2020' (Rec. 2020).</p> required <code>target_space</code> <code>str</code> <p>Target color space identifier. Options: 'bt709', 'p3', 'bt2020'.</p> required <code>clip</code> <code>bool</code> <p>Whether to clip output to [0, inf). Default: False. Enable when negative values from gamut mapping are undesirable.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Converted image in target color space, same shape as input.</p> <code>ndarray</code> <p>Values remain in linear light.</p> Note <p>If source_space equals target_space, returns input unchanged. Uses colour-science library for accurate color transformations.</p> See Also <ul> <li><code>apply_pq</code>: Apply PQ transfer function after color space conversion.</li> <li><code>gainmap_to_hdr</code>: Includes color space conversion in HDR reconstruction.</li> </ul> Source code in <code>src/hdrconv/convert/colorspace.py</code> <pre><code>def convert_color_space(\n    image: np.ndarray, source_space: str, target_space: str, clip: bool = False\n) -&gt; np.ndarray:\n    \"\"\"Convert image between color spaces.\n\n    Transforms RGB values from one color space to another using chromatic\n    adaptation and matrix transformations. Input must be in linear light.\n\n    Args:\n        image: Linear RGB image data, float32, shape (H, W, 3).\n            Values should be in linear light (not gamma-encoded).\n        source_space: Source color space identifier.\n            Options: 'bt709' (Rec. 709), 'p3' (Display P3), 'bt2020' (Rec. 2020).\n        target_space: Target color space identifier.\n            Options: 'bt709', 'p3', 'bt2020'.\n        clip: Whether to clip output to [0, inf). Default: False.\n            Enable when negative values from gamut mapping are undesirable.\n\n    Returns:\n        Converted image in target color space, same shape as input.\n        Values remain in linear light.\n\n    Note:\n        If source_space equals target_space, returns input unchanged.\n        Uses colour-science library for accurate color transformations.\n\n    See Also:\n        - `apply_pq`: Apply PQ transfer function after color space conversion.\n        - `gainmap_to_hdr`: Includes color space conversion in HDR reconstruction.\n    \"\"\"\n    space_map = {\"bt709\": \"ITU-R BT.709\", \"p3\": \"DCI-P3\", \"bt2020\": \"ITU-R BT.2020\"}\n\n    if source_space == target_space:\n        return image\n\n    source_name = space_map.get(source_space, source_space)\n    target_name = space_map.get(target_space, target_space)\n\n    target_image = colour.RGB_to_RGB(\n        image, input_colourspace=source_name, output_colourspace=target_name\n    )\n\n    if clip:\n        target_image = np.clip(target_image, 0.0, None)\n    return target_image\n</code></pre>"},{"location":"api/convert/#hdrconv.convert.gainmap_to_hdr","title":"<code>gainmap_to_hdr(data, baseline_color_space='p3', alt_color_space='p3', target_color_space='bt2020')</code>","text":"<p>Convert ISO 21496-1 Gainmap to linear HDR image.</p> <p>Applies the gainmap to the baseline image to reconstruct the alternate (HDR) representation using the ISO 21496-1 formula:</p> <ul> <li>G' = (G^(1/gamma)) * (max - min) + min</li> <li>L = 2^G'</li> <li>HDR = L * (baseline + baseline_offset) - alternate_offset</li> </ul> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>GainmapImage</code> <p>GainmapImage dict containing baseline, gainmap, and metadata.</p> required <code>baseline_color_space</code> <code>str</code> <p>Color space of baseline image. Options: 'bt709', 'p3', 'bt2020'. Default: 'p3'.</p> <code>'p3'</code> <code>alt_color_space</code> <code>str</code> <p>Color space of alternate/HDR image. Options: 'bt709', 'p3', 'bt2020'. Default: 'p3'.</p> <code>'p3'</code> <code>target_color_space</code> <code>str</code> <p>Target output color space. Options: 'bt709', 'p3', 'bt2020'. Default: 'bt2020'.</p> <code>'bt2020'</code> <p>Returns:</p> Type Description <code>HDRImage</code> <p>HDRImage dict with the following keys:</p> <code>HDRImage</code> <ul> <li><code>data</code> (np.ndarray): Linear HDR array, float32, shape (H, W, 3).</li> </ul> <code>HDRImage</code> <ul> <li><code>color_space</code> (str): Target color space string.</li> </ul> <code>HDRImage</code> <ul> <li><code>transfer_function</code> (str): Always 'linear'.</li> </ul> <code>HDRImage</code> <ul> <li><code>icc_profile</code> (bytes | None): Always None.</li> </ul> Note <p>The baseline image is assumed to be sRGB-encoded. The function automatically applies EOTF conversion to linear light before applying the gainmap formula.</p> See Also <ul> <li><code>hdr_to_gainmap</code>: Inverse operation, create gainmap from HDR.</li> <li><code>convert_color_space</code>: For additional color space transformations.</li> </ul> Source code in <code>src/hdrconv/convert/gainmap.py</code> <pre><code>def gainmap_to_hdr(\n    data: GainmapImage,\n    baseline_color_space: str = \"p3\",\n    alt_color_space: str = \"p3\",\n    target_color_space: str = \"bt2020\",\n) -&gt; HDRImage:\n    \"\"\"Convert ISO 21496-1 Gainmap to linear HDR image.\n\n    Applies the gainmap to the baseline image to reconstruct the alternate\n    (HDR) representation using the ISO 21496-1 formula:\n\n    - G' = (G^(1/gamma)) * (max - min) + min\n    - L = 2^G'\n    - HDR = L * (baseline + baseline_offset) - alternate_offset\n\n    Args:\n        data: GainmapImage dict containing baseline, gainmap, and metadata.\n        baseline_color_space: Color space of baseline image.\n            Options: 'bt709', 'p3', 'bt2020'. Default: 'p3'.\n        alt_color_space: Color space of alternate/HDR image.\n            Options: 'bt709', 'p3', 'bt2020'. Default: 'p3'.\n        target_color_space: Target output color space.\n            Options: 'bt709', 'p3', 'bt2020'. Default: 'bt2020'.\n\n    Returns:\n        HDRImage dict with the following keys:\n        - ``data`` (np.ndarray): Linear HDR array, float32, shape (H, W, 3).\n        - ``color_space`` (str): Target color space string.\n        - ``transfer_function`` (str): Always 'linear'.\n        - ``icc_profile`` (bytes | None): Always None.\n\n    Note:\n        The baseline image is assumed to be sRGB-encoded. The function\n        automatically applies EOTF conversion to linear light before\n        applying the gainmap formula.\n\n    See Also:\n        - `hdr_to_gainmap`: Inverse operation, create gainmap from HDR.\n        - `convert_color_space`: For additional color space transformations.\n    \"\"\"\n    baseline = data[\"baseline\"].astype(np.float32) / 255.0  # Normalize to [0, 1]\n    baseline = colour.eotf(baseline, function=\"sRGB\")\n    gainmap = data[\"gainmap\"].astype(np.float32) / 255.0\n    metadata = data[\"metadata\"]\n\n    use_base_colour_space = metadata[\"use_base_colour_space\"]\n    if not use_base_colour_space:\n        baseline = convert_color_space(\n            baseline,\n            source_space=baseline_color_space,\n            target_space=alt_color_space,\n        )\n    else:\n        gainmap = convert_color_space(\n            gainmap,\n            source_space=alt_color_space,\n            target_space=baseline_color_space,\n        )\n\n    # Resize gainmap to match baseline if needed\n    h, w = baseline.shape[:2]\n    if gainmap.shape[:2] != (h, w):\n        # Use Pillow for resizing: convert float32 [0,1] -&gt; uint8 [0,255] -&gt; resize -&gt; back to float32\n        gainmap_uint8 = np.clip(gainmap * 255.0, 0, 255).astype(np.uint8)\n\n        # Handle 2D grayscale and 3D RGB arrays\n        if gainmap_uint8.ndim == 2:\n            pil_image = Image.fromarray(gainmap_uint8, mode=\"L\")\n        else:\n            pil_image = Image.fromarray(gainmap_uint8, mode=\"RGB\")\n\n        # Resize using bilinear interpolation (equivalent to cv2.INTER_LINEAR)\n        pil_image_resized = pil_image.resize((w, h), Image.BILINEAR)\n\n        # Convert back to float32 [0,1]\n        gainmap = np.array(pil_image_resized, dtype=np.float32) / 255.0\n\n    # Ensure gainmap is 3-channel for calculations\n    if gainmap.ndim == 2:\n        gainmap = gainmap[:, :, np.newaxis]\n    if gainmap.shape[2] == 1:\n        gainmap = np.repeat(gainmap, 3, axis=2)\n\n    # Extract metadata (convert to arrays for broadcasting)\n    gainmap_min = np.array(metadata[\"gainmap_min\"], dtype=np.float32)\n    gainmap_max = np.array(metadata[\"gainmap_max\"], dtype=np.float32)\n    gainmap_gamma = np.array(metadata[\"gainmap_gamma\"], dtype=np.float32)\n    baseline_offset = np.array(metadata[\"baseline_offset\"], dtype=np.float32)\n    alternate_offset = np.array(metadata[\"alternate_offset\"], dtype=np.float32)\n\n    gainmap = np.clip(gainmap, 0.0, 1.0)\n\n    # Decode gainmap: apply gamma, scale, and offset\n    gainmap_decoded = (gainmap ** (1 / gainmap_gamma)) * (\n        gainmap_max - gainmap_min\n    ) + gainmap_min\n\n    # Convert to linear multiplier\n    gainmap_linear = np.exp2(gainmap_decoded)\n\n    # Reconstruct alternate (HDR) image\n    hdr_linear = gainmap_linear * (baseline + baseline_offset) - alternate_offset\n\n    # Color space conversion\n    if not use_base_colour_space:\n        hdr_linear = convert_color_space(\n            hdr_linear, source_space=alt_color_space, target_space=target_color_space\n        )\n    else:\n        hdr_linear = convert_color_space(\n            hdr_linear,\n            source_space=baseline_color_space,\n            target_space=target_color_space,\n        )\n\n    hdr_linear = np.clip(hdr_linear, 0.0, None)\n\n    return HDRImage(\n        data=hdr_linear,\n        color_space=target_color_space,\n        transfer_function=\"linear\",\n        icc_profile=None,\n    )\n</code></pre>"},{"location":"api/convert/#hdrconv.convert.hdr_to_gainmap","title":"<code>hdr_to_gainmap(hdr, baseline=None, color_space='bt709', icc_profile=None, gamma=1.0)</code>","text":"<p>Convert linear HDR image to ISO 21496-1 Gainmap format.</p> <p>Creates a gainmap by computing the log2 ratio between HDR and SDR images. If baseline is not provided, generates one by clipping HDR to [0, 1].</p> <p>Parameters:</p> Name Type Description Default <code>hdr</code> <code>HDRImage</code> <p>HDRImage dict with linear HDR data in any supported color space.</p> required <code>baseline</code> <code>Optional[ndarray]</code> <p>Optional pre-computed baseline (SDR) image. If None, generated by clipping HDR to [0, 1]. Expected format: float32, shape (H, W, 3), range [0, 1].</p> <code>None</code> <code>color_space</code> <code>str</code> <p>Target color space for output. Options: 'bt709', 'p3', 'bt2020'. Default: 'bt709'.</p> <code>'bt709'</code> <code>icc_profile</code> <code>Optional[bytes]</code> <p>Optional ICC profile bytes to embed in output. Should match the specified color_space.</p> <code>None</code> <code>gamma</code> <code>float</code> <p>Gainmap gamma parameter for encoding. Higher values compress highlights. Default: 1.0.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>GainmapImage</code> <p>GainmapImage dict containing:</p> <code>GainmapImage</code> <ul> <li><code>baseline</code> (np.ndarray): SDR image, uint8, shape (H, W, 3).</li> </ul> <code>GainmapImage</code> <ul> <li><code>gainmap</code> (np.ndarray): Gain map, uint8, shape (H, W, 3).</li> </ul> <code>GainmapImage</code> <ul> <li><code>metadata</code> (GainmapMetadata): Computed transformation parameters.</li> </ul> <code>GainmapImage</code> <ul> <li><code>baseline_icc</code> (bytes | None): Provided ICC profile.</li> </ul> <code>GainmapImage</code> <ul> <li><code>gainmap_icc</code> (bytes | None): Provided ICC profile.</li> </ul> Note <p>Uses fixed offsets of 1/64 for both baseline and alternate to avoid division by zero in dark regions.</p> See Also <ul> <li><code>gainmap_to_hdr</code>: Inverse operation, reconstruct HDR from gainmap.</li> <li><code>write_21496</code>: Write GainmapImage to ISO 21496-1 JPEG.</li> </ul> Source code in <code>src/hdrconv/convert/gainmap.py</code> <pre><code>def hdr_to_gainmap(\n    hdr: HDRImage,\n    baseline: Optional[np.ndarray] = None,\n    color_space: str = \"bt709\",\n    icc_profile: Optional[bytes] = None,\n    gamma: float = 1.0,\n) -&gt; GainmapImage:\n    \"\"\"Convert linear HDR image to ISO 21496-1 Gainmap format.\n\n    Creates a gainmap by computing the log2 ratio between HDR and SDR images.\n    If baseline is not provided, generates one by clipping HDR to [0, 1].\n\n    Args:\n        hdr: HDRImage dict with linear HDR data in any supported color space.\n        baseline: Optional pre-computed baseline (SDR) image.\n            If None, generated by clipping HDR to [0, 1].\n            Expected format: float32, shape (H, W, 3), range [0, 1].\n        color_space: Target color space for output.\n            Options: 'bt709', 'p3', 'bt2020'. Default: 'bt709'.\n        icc_profile: Optional ICC profile bytes to embed in output.\n            Should match the specified color_space.\n        gamma: Gainmap gamma parameter for encoding.\n            Higher values compress highlights. Default: 1.0.\n\n    Returns:\n        GainmapImage dict containing:\n        - ``baseline`` (np.ndarray): SDR image, uint8, shape (H, W, 3).\n        - ``gainmap`` (np.ndarray): Gain map, uint8, shape (H, W, 3).\n        - ``metadata`` (GainmapMetadata): Computed transformation parameters.\n        - ``baseline_icc`` (bytes | None): Provided ICC profile.\n        - ``gainmap_icc`` (bytes | None): Provided ICC profile.\n\n    Note:\n        Uses fixed offsets of 1/64 for both baseline and alternate to\n        avoid division by zero in dark regions.\n\n    See Also:\n        - `gainmap_to_hdr`: Inverse operation, reconstruct HDR from gainmap.\n        - `write_21496`: Write GainmapImage to ISO 21496-1 JPEG.\n    \"\"\"\n    hdr_data = hdr[\"data\"].astype(np.float32)\n\n    # convert to target colour space\n    hdr_data = convert_color_space(\n        hdr_data, source_space=hdr[\"color_space\"], target_space=color_space\n    )\n\n    hdr_data = np.clip(hdr_data, 0.0, None)\n\n    # Generate baseline if not provided\n    if baseline is None:\n        baseline = hdr_data.copy()\n        baseline = np.clip(baseline, 0.0, 1.0)\n\n    # Compute alt headroom\n    alt_headroom = np.log2(hdr_data.max() + 1e-6)\n\n    # preset offset for both baseline and alternate = 1/64\n    alt_offset = float(1 / 64)\n    base_offset = float(1 / 64)\n\n    ratio = (hdr_data + alt_offset) / (baseline + base_offset)\n    ratio = np.clip(ratio, 1e-6, None)\n\n    gainmap_log = np.log2(ratio)\n\n    gainmap_min_val = np.min(gainmap_log, axis=(0, 1))\n    gainmap_max_val = np.max(gainmap_log, axis=(0, 1))\n\n    gainmap_norm = (gainmap_log - gainmap_min_val) / (gainmap_max_val - gainmap_min_val)\n    gainmap_norm = np.clip(gainmap_norm, 0, 1)\n\n    gainmap_norm = gainmap_norm**gamma\n\n    gainmap_uint8 = (gainmap_norm * 255).astype(np.uint8)\n\n    baseline = colour.eotf_inverse(baseline, function=\"sRGB\")\n    baseline_uint8 = (baseline * 255).astype(np.uint8)\n\n    gainmap_min_val = tuple(gainmap_min_val.tolist())\n    gainmap_max_val = tuple(gainmap_max_val.tolist())\n\n    metadata = GainmapMetadata(\n        minimum_version=0,\n        writer_version=0,\n        baseline_hdr_headroom=1.0,\n        alternate_hdr_headroom=float(alt_headroom),\n        is_multichannel=True,\n        use_base_colour_space=True,\n        gainmap_min=gainmap_min_val,\n        gainmap_max=gainmap_max_val,\n        gainmap_gamma=(gamma, gamma, gamma),\n        baseline_offset=(base_offset, base_offset, base_offset),\n        alternate_offset=(alt_offset, alt_offset, alt_offset),\n    )\n\n    return GainmapImage(\n        baseline=baseline_uint8,\n        gainmap=gainmap_uint8,\n        metadata=metadata,\n        baseline_icc=icc_profile,\n        gainmap_icc=icc_profile,\n    )\n</code></pre>"},{"location":"api/convert/#hdrconv.convert.apply_pq","title":"<code>apply_pq(linear_rgb)</code>","text":"<p>Apply PQ (Perceptual Quantizer) transfer function.</p> <p>Encodes linear light RGB values to PQ (SMPTE ST 2084) transfer function as specified in ITU-R BT.2100 for HDR content.</p> <p>Parameters:</p> Name Type Description Default <code>linear_rgb</code> <code>ndarray</code> <p>Linear RGB data, float32, shape (H, W, 3). Values should be normalized where 1.0 = 203 nits (reference white). Values above 1.0 represent HDR highlights up to ~49x (10000 nits).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>PQ-encoded data, float32, shape (H, W, 3), range [0, 1].</p> <code>ndarray</code> <p>Output is clipped to valid PQ range.</p> Note <p>Uses 203 nits as reference white (PQ specification). Linear value of 1.0 maps to ~58% in PQ code values.</p> See Also <ul> <li><code>inverse_pq</code>: Decode PQ back to linear light.</li> <li><code>write_22028_pq</code>: Write PQ-encoded data to AVIF file.</li> </ul> Source code in <code>src/hdrconv/convert/transfer.py</code> <pre><code>def apply_pq(linear_rgb: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Apply PQ (Perceptual Quantizer) transfer function.\n\n    Encodes linear light RGB values to PQ (SMPTE ST 2084) transfer function\n    as specified in ITU-R BT.2100 for HDR content.\n\n    Args:\n        linear_rgb: Linear RGB data, float32, shape (H, W, 3).\n            Values should be normalized where 1.0 = 203 nits (reference white).\n            Values above 1.0 represent HDR highlights up to ~49x (10000 nits).\n\n    Returns:\n        PQ-encoded data, float32, shape (H, W, 3), range [0, 1].\n        Output is clipped to valid PQ range.\n\n    Note:\n        Uses 203 nits as reference white (PQ specification).\n        Linear value of 1.0 maps to ~58% in PQ code values.\n\n    See Also:\n        - `inverse_pq`: Decode PQ back to linear light.\n        - `write_22028_pq`: Write PQ-encoded data to AVIF file.\n    \"\"\"\n    # Normalize to reference white (203 nits in PQ)\n    pq_encoded = colour.models.eotf_inverse_BT2100_PQ(linear_rgb * 203.0)\n    pq_encoded = np.clip(pq_encoded, 0.0, 1.0)\n    return pq_encoded\n</code></pre>"},{"location":"api/convert/#hdrconv.convert.inverse_pq","title":"<code>inverse_pq(pq_encoded)</code>","text":"<p>Decode PQ-encoded values to linear light RGB.</p> <p>Applies the inverse PQ (SMPTE ST 2084) EOTF to convert PQ-encoded values back to linear light as specified in ITU-R BT.2100.</p> <p>Parameters:</p> Name Type Description Default <code>pq_encoded</code> <code>ndarray</code> <p>PQ-encoded data, float32, shape (H, W, 3), range [0, 1]. Values represent 0-10000 nits in PQ perceptual scale.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Linear RGB data, float32, shape (H, W, 3).</p> <code>ndarray</code> <p>Normalized where 1.0 = 203 nits (reference white).</p> <code>ndarray</code> <p>HDR highlights may exceed 1.0 up to ~49x.</p> Note <p>Uses 203 nits as reference white (PQ specification). PQ code value of ~0.58 maps to linear 1.0.</p> See Also <ul> <li><code>apply_pq</code>: Encode linear light to PQ.</li> <li><code>read_22028_pq</code>: Read PQ-encoded AVIF file.</li> </ul> Source code in <code>src/hdrconv/convert/transfer.py</code> <pre><code>def inverse_pq(pq_encoded: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Decode PQ-encoded values to linear light RGB.\n\n    Applies the inverse PQ (SMPTE ST 2084) EOTF to convert PQ-encoded\n    values back to linear light as specified in ITU-R BT.2100.\n\n    Args:\n        pq_encoded: PQ-encoded data, float32, shape (H, W, 3), range [0, 1].\n            Values represent 0-10000 nits in PQ perceptual scale.\n\n    Returns:\n        Linear RGB data, float32, shape (H, W, 3).\n        Normalized where 1.0 = 203 nits (reference white).\n        HDR highlights may exceed 1.0 up to ~49x.\n\n    Note:\n        Uses 203 nits as reference white (PQ specification).\n        PQ code value of ~0.58 maps to linear 1.0.\n\n    See Also:\n        - `apply_pq`: Encode linear light to PQ.\n        - `read_22028_pq`: Read PQ-encoded AVIF file.\n    \"\"\"\n    linear_normalized = colour.models.eotf_BT2100_PQ(pq_encoded)\n    linear_rgb = linear_normalized / 203.0\n    return linear_rgb\n</code></pre>"},{"location":"api/core/","title":"Core Types","text":""},{"location":"api/core/#hdrconv.core","title":"<code>hdrconv.core</code>","text":"<p>Core data types for HDR conversion.</p> <p>This module contains the TypedDict-based structures shared across the library for representing HDR images, gainmaps, and associated metadata.</p> Public Types <ul> <li><code>GainmapImage</code>: ISO 21496-1 gainmap container</li> <li><code>GainmapMetadata</code>: Gainmap transformation parameters</li> <li><code>HDRImage</code>: Linear or transfer-encoded HDR image</li> <li><code>AppleHeicData</code>: Apple HEIC gainmap container</li> </ul>"},{"location":"api/core/#hdrconv.core.AppleHeicData","title":"<code>AppleHeicData</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Apple HEIC HDR image data structure.</p> <p>Contains the base (SDR) image, single-channel gainmap, and headroom value used by Apple's proprietary HDR gain map format in iPhone photos.</p> The HDR reconstruction formula is <p>hdr_rgb = sdr_rgb * (1.0 + (headroom - 1.0) * gainmap)</p> <p>Attributes:</p> Name Type Description <code>base</code> <code>ndarray</code> <p>Base SDR image array, uint8, shape (H, W, 3), range [0, 255]. Encoded in Display P3 color space with sRGB transfer function.</p> <code>gainmap</code> <code>ndarray</code> <p>Gain map array, uint8, shape (H, W, 1), range [0, 255]. Single-channel map at 1/4 resolution of base image. Uses Rec. 709 transfer function internally.</p> <code>headroom</code> <code>float</code> <p>Peak luminance headroom value, typically 2.0-8.0. Represents the maximum brightness multiplier for HDR highlights.</p> See Also <ul> <li><code>read_apple_heic</code>: Read AppleHeicData from HEIC file.</li> <li><code>apple_heic_to_hdr</code>: Convert AppleHeicData to linear HDRImage.</li> </ul> Source code in <code>src/hdrconv/core/types.py</code> <pre><code>class AppleHeicData(TypedDict):\n    \"\"\"Apple HEIC HDR image data structure.\n\n    Contains the base (SDR) image, single-channel gainmap, and headroom value\n    used by Apple's proprietary HDR gain map format in iPhone photos.\n\n    The HDR reconstruction formula is:\n        hdr_rgb = sdr_rgb * (1.0 + (headroom - 1.0) * gainmap)\n\n    Attributes:\n        base: Base SDR image array, uint8, shape (H, W, 3), range [0, 255].\n            Encoded in Display P3 color space with sRGB transfer function.\n        gainmap: Gain map array, uint8, shape (H, W, 1), range [0, 255].\n            Single-channel map at 1/4 resolution of base image.\n            Uses Rec. 709 transfer function internally.\n        headroom: Peak luminance headroom value, typically 2.0-8.0.\n            Represents the maximum brightness multiplier for HDR highlights.\n\n    See Also:\n        - `read_apple_heic`: Read AppleHeicData from HEIC file.\n        - `apple_heic_to_hdr`: Convert AppleHeicData to linear HDRImage.\n    \"\"\"\n\n    base: np.ndarray\n    gainmap: np.ndarray\n    headroom: float\n</code></pre>"},{"location":"api/core/#hdrconv.core.AppleHeicData.base","title":"<code>base</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#hdrconv.core.AppleHeicData.gainmap","title":"<code>gainmap</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#hdrconv.core.AppleHeicData.headroom","title":"<code>headroom</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#hdrconv.core.GainmapImage","title":"<code>GainmapImage</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>ISO 21496-1 Gainmap image structure.</p> <p>Contains the baseline (SDR) image, gainmap, and associated metadata required for HDR reconstruction using the ISO 21496-1 formula.</p> <p>Attributes:</p> Name Type Description <code>baseline</code> <code>ndarray</code> <p>SDR image array, uint8, shape (H, W, 3), range [0, 255]. Typically sRGB-encoded Display P3 or BT.709 content.</p> <code>gainmap</code> <code>ndarray</code> <p>Gain map array, uint8, shape (H, W, 3) or (H, W, 1), range [0, 255]. Encodes the HDR-to-SDR ratio in log2 space.</p> <code>metadata</code> <code>GainmapMetadata</code> <p>GainmapMetadata dict containing transformation parameters such as gamma, min/max values, and offsets.</p> <code>baseline_icc</code> <code>Optional[bytes]</code> <p>Optional ICC profile bytes for baseline image color space.</p> <code>gainmap_icc</code> <code>Optional[bytes]</code> <p>Optional ICC profile bytes for gainmap color space.</p> See Also <ul> <li><code>read_21496</code>: Read GainmapImage from ISO 21496-1 JPEG file.</li> <li><code>gainmap_to_hdr</code>: Convert GainmapImage to linear HDR.</li> </ul> Source code in <code>src/hdrconv/core/types.py</code> <pre><code>class GainmapImage(TypedDict):\n    \"\"\"ISO 21496-1 Gainmap image structure.\n\n    Contains the baseline (SDR) image, gainmap, and associated metadata\n    required for HDR reconstruction using the ISO 21496-1 formula.\n\n    Attributes:\n        baseline: SDR image array, uint8, shape (H, W, 3), range [0, 255].\n            Typically sRGB-encoded Display P3 or BT.709 content.\n        gainmap: Gain map array, uint8, shape (H, W, 3) or (H, W, 1),\n            range [0, 255]. Encodes the HDR-to-SDR ratio in log2 space.\n        metadata: GainmapMetadata dict containing transformation parameters\n            such as gamma, min/max values, and offsets.\n        baseline_icc: Optional ICC profile bytes for baseline image color space.\n        gainmap_icc: Optional ICC profile bytes for gainmap color space.\n\n    See Also:\n        - `read_21496`: Read GainmapImage from ISO 21496-1 JPEG file.\n        - `gainmap_to_hdr`: Convert GainmapImage to linear HDR.\n    \"\"\"\n\n    baseline: np.ndarray\n    gainmap: np.ndarray\n    metadata: GainmapMetadata\n    baseline_icc: Optional[bytes]\n    gainmap_icc: Optional[bytes]\n</code></pre>"},{"location":"api/core/#hdrconv.core.GainmapImage.baseline","title":"<code>baseline</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#hdrconv.core.GainmapImage.gainmap","title":"<code>gainmap</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#hdrconv.core.GainmapImage.metadata","title":"<code>metadata</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#hdrconv.core.GainmapImage.baseline_icc","title":"<code>baseline_icc</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#hdrconv.core.GainmapImage.gainmap_icc","title":"<code>gainmap_icc</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#hdrconv.core.GainmapMetadata","title":"<code>GainmapMetadata</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>ISO 21496-1 Gainmap metadata structure.</p> <p>Contains transformation parameters for converting between baseline (SDR) and alternate (HDR) representations as defined in ISO 21496-1.</p> <p>Attributes:</p> Name Type Description <code>minimum_version</code> <code>int</code> <p>Minimum decoder version required. Should be 0.</p> <code>writer_version</code> <code>int</code> <p>Version of the encoder that created the metadata.</p> <code>baseline_hdr_headroom</code> <code>float</code> <p>HDR headroom of baseline image, typically 1.0.</p> <code>alternate_hdr_headroom</code> <code>float</code> <p>HDR headroom of alternate image (e.g., 4.5).</p> <code>is_multichannel</code> <code>bool</code> <p>True if gainmap has separate RGB channels, False for single channel.</p> <code>use_base_colour_space</code> <code>bool</code> <p>True to compute in baseline color space, False for alternate.</p> <code>gainmap_min</code> <code>Tuple[float, float, float]</code> <p>Minimum gainmap values per channel, tuple of 3 floats.</p> <code>gainmap_max</code> <code>Tuple[float, float, float]</code> <p>Maximum gainmap values per channel, tuple of 3 floats.</p> <code>gainmap_gamma</code> <code>Tuple[float, float, float]</code> <p>Gamma values per channel for gainmap decoding, tuple of 3 floats.</p> <code>baseline_offset</code> <code>Tuple[float, float, float]</code> <p>Offset added to baseline before multiplication, tuple of 3 floats.</p> <code>alternate_offset</code> <code>Tuple[float, float, float]</code> <p>Offset subtracted from result, tuple of 3 floats.</p> Source code in <code>src/hdrconv/core/types.py</code> <pre><code>class GainmapMetadata(TypedDict, total=False):\n    \"\"\"ISO 21496-1 Gainmap metadata structure.\n\n    Contains transformation parameters for converting between baseline (SDR)\n    and alternate (HDR) representations as defined in ISO 21496-1.\n\n    Attributes:\n        minimum_version: Minimum decoder version required. Should be 0.\n        writer_version: Version of the encoder that created the metadata.\n        baseline_hdr_headroom: HDR headroom of baseline image, typically 1.0.\n        alternate_hdr_headroom: HDR headroom of alternate image (e.g., 4.5).\n        is_multichannel: True if gainmap has separate RGB channels, False for single channel.\n        use_base_colour_space: True to compute in baseline color space, False for alternate.\n        gainmap_min: Minimum gainmap values per channel, tuple of 3 floats.\n        gainmap_max: Maximum gainmap values per channel, tuple of 3 floats.\n        gainmap_gamma: Gamma values per channel for gainmap decoding, tuple of 3 floats.\n        baseline_offset: Offset added to baseline before multiplication, tuple of 3 floats.\n        alternate_offset: Offset subtracted from result, tuple of 3 floats.\n\n    \"\"\"\n\n    # Version information\n    minimum_version: int\n    writer_version: int\n\n    # HDR headroom values\n    baseline_hdr_headroom: float\n    alternate_hdr_headroom: float\n\n    # Channel configuration\n    is_multichannel: bool\n    use_base_colour_space: bool\n\n    # Gainmap transformation parameters (RGB triplets)\n    gainmap_min: Tuple[float, float, float]\n    gainmap_max: Tuple[float, float, float]\n    gainmap_gamma: Tuple[float, float, float]\n\n    # Offset parameters (RGB triplets)\n    baseline_offset: Tuple[float, float, float]\n    alternate_offset: Tuple[float, float, float]\n</code></pre>"},{"location":"api/core/#hdrconv.core.GainmapMetadata.minimum_version","title":"<code>minimum_version</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#hdrconv.core.GainmapMetadata.writer_version","title":"<code>writer_version</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#hdrconv.core.GainmapMetadata.baseline_hdr_headroom","title":"<code>baseline_hdr_headroom</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#hdrconv.core.GainmapMetadata.alternate_hdr_headroom","title":"<code>alternate_hdr_headroom</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#hdrconv.core.GainmapMetadata.is_multichannel","title":"<code>is_multichannel</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#hdrconv.core.GainmapMetadata.use_base_colour_space","title":"<code>use_base_colour_space</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#hdrconv.core.GainmapMetadata.gainmap_min","title":"<code>gainmap_min</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#hdrconv.core.GainmapMetadata.gainmap_max","title":"<code>gainmap_max</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#hdrconv.core.GainmapMetadata.gainmap_gamma","title":"<code>gainmap_gamma</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#hdrconv.core.GainmapMetadata.baseline_offset","title":"<code>baseline_offset</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#hdrconv.core.GainmapMetadata.alternate_offset","title":"<code>alternate_offset</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#hdrconv.core.HDRImage","title":"<code>HDRImage</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>HDR image representation with color metadata.</p> <p>Contains linear or transfer-encoded RGB data with associated color space and transfer function information for proper display and conversion.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>ndarray</code> <p>Image data array, float32, shape (H, W, 3). For linear transfer: values in linear light, range [0, peak_luminance/reference_white]. For PQ transfer: values in range [0, 1] representing 0-10000 nits. For HLG transfer: values in range [0, 1] representing scene-referred light.</p> <code>color_space</code> <code>str</code> <p>Color primaries identifier. Options: 'bt709' (Rec. 709), 'p3' (Display P3), 'bt2020' (Rec. 2020).</p> <code>transfer_function</code> <code>str</code> <p>Transfer function applied to the data. Options: 'linear', 'pq' (SMPTE ST 2084), 'hlg' (ITU-R BT.2100), 'srgb'.</p> <code>icc_profile</code> <code>Optional[bytes]</code> <p>Optional ICC profile bytes for custom color space definition.</p> See Also <ul> <li><code>gainmap_to_hdr</code>: Create HDRImage from GainmapImage.</li> <li><code>apply_pq</code>: Apply PQ transfer function to linear HDRImage.</li> </ul> Source code in <code>src/hdrconv/core/types.py</code> <pre><code>class HDRImage(TypedDict):\n    \"\"\"HDR image representation with color metadata.\n\n    Contains linear or transfer-encoded RGB data with associated color space\n    and transfer function information for proper display and conversion.\n\n    Attributes:\n        data: Image data array, float32, shape (H, W, 3).\n            For linear transfer: values in linear light, range [0, peak_luminance/reference_white].\n            For PQ transfer: values in range [0, 1] representing 0-10000 nits.\n            For HLG transfer: values in range [0, 1] representing scene-referred light.\n        color_space: Color primaries identifier.\n            Options: 'bt709' (Rec. 709), 'p3' (Display P3), 'bt2020' (Rec. 2020).\n        transfer_function: Transfer function applied to the data.\n            Options: 'linear', 'pq' (SMPTE ST 2084), 'hlg' (ITU-R BT.2100), 'srgb'.\n        icc_profile: Optional ICC profile bytes for custom color space definition.\n\n    See Also:\n        - `gainmap_to_hdr`: Create HDRImage from GainmapImage.\n        - `apply_pq`: Apply PQ transfer function to linear HDRImage.\n    \"\"\"\n\n    data: np.ndarray\n    color_space: str\n    transfer_function: str\n    icc_profile: Optional[bytes]\n</code></pre>"},{"location":"api/core/#hdrconv.core.HDRImage.data","title":"<code>data</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#hdrconv.core.HDRImage.color_space","title":"<code>color_space</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#hdrconv.core.HDRImage.transfer_function","title":"<code>transfer_function</code>  <code>instance-attribute</code>","text":""},{"location":"api/core/#hdrconv.core.HDRImage.icc_profile","title":"<code>icc_profile</code>  <code>instance-attribute</code>","text":""},{"location":"api/identify/","title":"Identify","text":""},{"location":"api/identify/#hdrconv.identify","title":"<code>hdrconv.identify</code>","text":"<p>HDR format identification helpers.</p> <p>This module provides functions for detecting HDR content and metadata in various image formats.</p> Public APIs <ul> <li><code>has_gain_map</code>: Check if Apple HEIC file contains HDR gain map</li> </ul>"},{"location":"api/identify/#hdrconv.identify.has_gain_map","title":"<code>has_gain_map(input_path)</code>","text":"<p>Check if Apple HEIC file contains HDR gain map.</p> <p>Scans the auxiliary images in a HEIC file to detect the presence of Apple's HDR gain map (URN: urn:com:apple:photo:2020:aux:hdrgainmap).</p> <p>Parameters:</p> Name Type Description Default <code>input_path</code> <code>str</code> <p>Path to the input HEIC image file.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if an HDR gain map auxiliary image is found, False otherwise.</p> Note <p>This function does not validate the gain map data itself, only checks for its presence in the file metadata.</p> See Also <ul> <li><code>read_apple_heic</code>: Extract gain map data from HEIC file.</li> </ul> Source code in <code>src/hdrconv/identify/apple_heic.py</code> <pre><code>def has_gain_map(input_path: str) -&gt; bool:\n    \"\"\"Check if Apple HEIC file contains HDR gain map.\n\n    Scans the auxiliary images in a HEIC file to detect the presence of\n    Apple's HDR gain map (URN: urn:com:apple:photo:2020:aux:hdrgainmap).\n\n    Args:\n        input_path: Path to the input HEIC image file.\n\n    Returns:\n        True if an HDR gain map auxiliary image is found, False otherwise.\n\n    Note:\n        This function does not validate the gain map data itself, only\n        checks for its presence in the file metadata.\n\n    See Also:\n        - `read_apple_heic`: Extract gain map data from HEIC file.\n    \"\"\"\n    has_gain_map = False\n    heif_file = pillow_heif.read_heif(input_path, convert_hdr_to_8bit=False)\n\n    if \"aux\" in heif_file.info:\n        aux_info = heif_file.info[\"aux\"]\n        for urn, ids in aux_info.items():\n            # print(f\"  URN: {urn}, IDs: {ids}\")\n            if urn == HDR_GAIN_MAP_URN:\n                has_gain_map = True\n    return has_gain_map\n</code></pre>"},{"location":"api/io/","title":"I/O","text":""},{"location":"api/io/#hdrconv.io","title":"<code>hdrconv.io</code>","text":"<p>HDR format I/O operations.</p> <p>This module provides functions for reading and writing various HDR formats:</p> <ul> <li>ISO 21496-1 (Adaptive Gainmap): <code>read_21496</code>, <code>write_21496</code></li> <li>ISO 22028-5 (PQ/HLG AVIF): <code>read_22028_pq</code>, <code>write_22028_pq</code></li> <li>Apple HEIC with gainmap: <code>read_apple_heic</code></li> <li>iOS HDR screenshot: <code>read_ios_hdr_screenshot</code></li> </ul>"},{"location":"api/io/#hdrconv.io.read_21496","title":"<code>read_21496(filepath)</code>","text":"<p>Read ISO 21496-1 Gainmap JPEG file.</p> <p>Parses a JPEG file containing an ISO 21496-1 compliant gainmap with Multi-Picture Format (MPF) container structure.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to the ISO 21496-1 JPEG file.</p> required <p>Returns:</p> Type Description <code>GainmapImage</code> <p>GainmapImage dict containing:</p> <code>GainmapImage</code> <ul> <li><code>baseline</code> (np.ndarray): SDR image, uint8, shape (H, W, 3), range [0, 255].</li> </ul> <code>GainmapImage</code> <ul> <li><code>gainmap</code> (np.ndarray): Gain map, uint8, shape (H, W, 3) or (H, W, 1).</li> </ul> <code>GainmapImage</code> <ul> <li><code>metadata</code> (GainmapMetadata): Transformation parameters including gamma, min/max values, offsets, and headroom.</li> </ul> <code>GainmapImage</code> <ul> <li><code>baseline_icc</code> (bytes | None): ICC profile for baseline image.</li> </ul> <code>GainmapImage</code> <ul> <li><code>gainmap_icc</code> (bytes | None): ICC profile for gainmap.</li> </ul> <p>Raises:</p> Type Description <code>ValueError</code> <p>If gainmap is not found in MPF container.</p> <code>ValueError</code> <p>If ISO 21496-1 metadata segment is missing.</p> Note <p>The file must contain a valid MPF structure with the gainmap as the secondary image and ISO 21496-1 metadata in an APP2 segment.</p> See Also <ul> <li><code>write_21496</code>: Write GainmapImage to ISO 21496-1 format.</li> <li><code>gainmap_to_hdr</code>: Convert GainmapImage to linear HDR.</li> </ul> Source code in <code>src/hdrconv/io/iso21496.py</code> <pre><code>def read_21496(filepath: str) -&gt; GainmapImage:\n    \"\"\"Read ISO 21496-1 Gainmap JPEG file.\n\n    Parses a JPEG file containing an ISO 21496-1 compliant gainmap with\n    Multi-Picture Format (MPF) container structure.\n\n    Args:\n        filepath: Path to the ISO 21496-1 JPEG file.\n\n    Returns:\n        GainmapImage dict containing:\n        - ``baseline`` (np.ndarray): SDR image, uint8, shape (H, W, 3), range [0, 255].\n        - ``gainmap`` (np.ndarray): Gain map, uint8, shape (H, W, 3) or (H, W, 1).\n        - ``metadata`` (GainmapMetadata): Transformation parameters including\n            gamma, min/max values, offsets, and headroom.\n        - ``baseline_icc`` (bytes | None): ICC profile for baseline image.\n        - ``gainmap_icc`` (bytes | None): ICC profile for gainmap.\n\n    Raises:\n        ValueError: If gainmap is not found in MPF container.\n        ValueError: If ISO 21496-1 metadata segment is missing.\n\n    Note:\n        The file must contain a valid MPF structure with the gainmap as\n        the secondary image and ISO 21496-1 metadata in an APP2 segment.\n\n    See Also:\n        - `write_21496`: Write GainmapImage to ISO 21496-1 format.\n        - `gainmap_to_hdr`: Convert GainmapImage to linear HDR.\n    \"\"\"\n    with open(filepath, \"rb\") as f:\n        raw_data = f.read()\n\n    # 1. Split streams (Primary vs Gainmap) via MPF\n    primary_data, gainmap_data = _split_mpf_container(raw_data)\n\n    if not gainmap_data:\n        raise ValueError(\"No gainmap found in container (MPF missing or invalid).\")\n\n    # 2. Decode Images\n    # Suppress MPO-related warnings from Pillow when reading JPEG streams\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\n            \"ignore\",\n            message=\"Image appears to be a malformed MPO file\",\n            category=UserWarning,\n        )\n        base_img = Image.open(io.BytesIO(primary_data)).convert(\"RGB\")\n        gain_img = Image.open(io.BytesIO(gainmap_data)).convert(\"RGB\")\n\n    base_arr = np.array(base_img)\n    gain_arr = np.array(gain_img)\n\n    # 3. Extract Metadata &amp; ICC\n    # Metadata usually lives in the Gainmap stream's APP2, but we check both.\n\n    base_segments = list(_yield_jpeg_segments(primary_data))\n    gain_segments = list(_yield_jpeg_segments(gainmap_data))\n\n    base_icc = _extract_icc(base_segments)\n    gain_icc = _extract_icc(gain_segments)\n\n    iso_meta = None\n\n    # Search for ISO 21496 metadata (Prioritize Gainmap stream)\n    for segments in [gain_segments, base_segments]:\n        for code, payload in segments:\n            if code == APP2 and (\n                payload.startswith(ISO21496_URN) or payload.startswith(ISO21496_URN_ALT)\n            ):\n                iso_meta = _parse_iso21496_metadata(payload)\n                break\n        if iso_meta:\n            break\n\n    if not iso_meta:\n        raise ValueError(\"ISO 21496-1 metadata segment not found.\")\n\n    return GainmapImage(\n        baseline=base_arr,\n        gainmap=gain_arr,\n        metadata=iso_meta,\n        baseline_icc=base_icc,\n        gainmap_icc=gain_icc,\n    )\n</code></pre>"},{"location":"api/io/#hdrconv.io.write_21496","title":"<code>write_21496(data, filepath)</code>","text":"<p>Write ISO 21496-1 Gainmap JPEG file.</p> <p>Creates a JPEG file with ISO 21496-1 compliant gainmap structure using Multi-Picture Format (MPF) container.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>GainmapImage</code> <p>GainmapImage dict containing: - <code>baseline</code>: SDR image, uint8, shape (H, W, 3). - <code>gainmap</code>: Gain map, uint8, shape (H, W, 3) or (H, W, 1). - <code>metadata</code>: GainmapMetadata with transformation parameters. - <code>baseline_icc</code>: Optional ICC profile for baseline. - <code>gainmap_icc</code>: Optional ICC profile for gainmap.</p> required <code>filepath</code> <code>str</code> <p>Output path for the JPEG file.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If file writing fails.</p> Note <p>The output file structure places the baseline image first with an MPF index, followed by the gainmap with ISO 21496-1 metadata. JPEG quality is set to 95 with 4:4:4 chroma subsampling.</p> See Also <ul> <li><code>read_21496</code>: Read ISO 21496-1 Gainmap JPEG.</li> <li><code>hdr_to_gainmap</code>: Convert HDR image to GainmapImage.</li> </ul> Source code in <code>src/hdrconv/io/iso21496.py</code> <pre><code>def write_21496(data: GainmapImage, filepath: str) -&gt; None:\n    \"\"\"Write ISO 21496-1 Gainmap JPEG file.\n\n    Creates a JPEG file with ISO 21496-1 compliant gainmap structure using\n    Multi-Picture Format (MPF) container.\n\n    Args:\n        data: GainmapImage dict containing:\n            - ``baseline``: SDR image, uint8, shape (H, W, 3).\n            - ``gainmap``: Gain map, uint8, shape (H, W, 3) or (H, W, 1).\n            - ``metadata``: GainmapMetadata with transformation parameters.\n            - ``baseline_icc``: Optional ICC profile for baseline.\n            - ``gainmap_icc``: Optional ICC profile for gainmap.\n        filepath: Output path for the JPEG file.\n\n    Raises:\n        RuntimeError: If file writing fails.\n\n    Note:\n        The output file structure places the baseline image first with an\n        MPF index, followed by the gainmap with ISO 21496-1 metadata.\n        JPEG quality is set to 95 with 4:4:4 chroma subsampling.\n\n    See Also:\n        - `read_21496`: Read ISO 21496-1 Gainmap JPEG.\n        - `hdr_to_gainmap`: Convert HDR image to GainmapImage.\n    \"\"\"\n    try:\n        # 1. \u7f16\u7801 Gainmap \u56fe\u50cf (\u57fa\u7840 JPEG \u7f16\u7801)\n        gainmap_bytes_raw = _create_jpeg_bytes(data[\"gainmap\"], data.get(\"gainmap_icc\"))\n\n        # 1.1 \u5728 Gainmap \u6d41\u4e2d\u63d2\u5165\u4e00\u4e2a\u6700\u5c0f MPF APP2\uff08\u517c\u5bb9\u6027\u9700\u8981\uff09\n        gainmap_mpf_segment = _build_app2_segment(_build_mpf_minimal_payload(2))\n\n        # 2. \u6784\u5efa ISO 21496-1 \u5143\u6570\u636e\u6bb5 (APP2)\n        #    \u6807\u51c6\u5efa\u8bae\u5c06\u6b64\u5143\u6570\u636e\u653e\u5728 Gainmap \u56fe\u50cf\u6d41\u4e2d\n        iso_payload = _encode_iso21496_metadata(data[\"metadata\"])\n        iso_segment = _build_app2_segment(iso_payload)\n\n        #    \u5c06 ISO \u6bb5\u63d2\u5165\u5230 Gainmap \u7684 SOI (0xFFD8) \u4e4b\u540e\n        gainmap_final = (\n            gainmap_bytes_raw[:2]\n            + gainmap_mpf_segment\n            + iso_segment\n            + gainmap_bytes_raw[2:]\n        )\n\n        # 3. \u7f16\u7801 Baseline \u56fe\u50cf (\u57fa\u7840 JPEG \u7f16\u7801)\n        primary_bytes_raw = _create_jpeg_bytes(\n            data[\"baseline\"], data.get(\"baseline_icc\")\n        )\n\n        # 3.1 \u5728 Primary \u6d41\u4e2d\u63d2\u5165\u4e00\u4e2a\u77ed URN stub APP2\uff08\u517c\u5bb9\u6027\u9700\u8981\uff09\n        # \u8be5 stub \u4e0d\u662f\u5b8c\u6574\u5143\u6570\u636e\uff0c\u4ec5\u7528\u4e8e\u6807\u8bb0 ISO21496 \u5bb9\u5668\u3002\n        primary_stub_segment = _build_app2_segment(ISO21496_URN + b\"\\x00\\x00\\x00\\x00\")\n\n        # 4. \u6784\u5efa MPF \u7d22\u5f15\u6bb5 (APP2)\n        #    MPF \u4f4d\u4e8e Baseline \u56fe\u50cf\u4e2d\uff0c\u7528\u4e8e\u6307\u5411\u6587\u4ef6\u672b\u5c3e\u7684 Gainmap\n\n        #    A. \u9996\u5148\u751f\u6210\u4e00\u4e2a\u5e26\u6709\u5360\u4f4d\u504f\u79fb\u91cf\u7684 MPF payload\uff0c\u7528\u4e8e\u8ba1\u7b97\u957f\u5ea6\n        #       MPF \u6bb5\u653e\u5728 Primary stub \u4e4b\u540e\n        mpf_payload_temp = _build_mpf_payload(\n            primary_size=len(primary_bytes_raw),  # \u6682\u65f6\u7684\uff0c\u7a0d\u540e\u4fee\u6b63\n            gainmap_size=len(gainmap_final),\n            gainmap_offset=0,  # \u5360\u4f4d\n        )\n        mpf_segment_temp = _build_app2_segment(mpf_payload_temp)\n\n        #    B. \u8ba1\u7b97\u6700\u7ec8\u6587\u4ef6\u7ed3\u6784\u4e2d\u7684\u7edd\u5bf9\u4f4d\u7f6e\n        #       Primary_Final_Len = Raw_Primary_Len + Stub_Seg_Len + MPF_Seg_Len\n        total_primary_len = (\n            len(primary_bytes_raw) + len(primary_stub_segment) + len(mpf_segment_temp)\n        )\n\n        #    C. \u8ba1\u7b97 Gainmap \u7684\u76f8\u5bf9\u504f\u79fb\u91cf\n        #       MPF \u6807\u51c6\u89c4\u5b9a\u504f\u79fb\u91cf\u662f\u76f8\u5bf9\u4e8e MPF Header (\u5373 'MM'/'II' \u5b57\u8282) \u7684\u4f4d\u7f6e\n        #       base_file_offset = MPF marker \u7684\u6587\u4ef6\u504f\u79fb + 8 (marker+len+\"MPF\\0\")\n        mpf_marker_offset = 2 + len(primary_stub_segment)\n        mpf_base_file_offset = mpf_marker_offset + 8\n        gainmap_relative_offset = total_primary_len - mpf_base_file_offset\n\n        #    D. \u91cd\u65b0\u751f\u6210\u5305\u542b\u6b63\u786e Primary \u5927\u5c0f\u548c Gainmap \u504f\u79fb\u91cf\u7684 MPF payload\n        mpf_payload_final = _build_mpf_payload(\n            primary_size=total_primary_len,\n            gainmap_size=len(gainmap_final),\n            gainmap_offset=gainmap_relative_offset,\n        )\n        mpf_segment_final = _build_app2_segment(mpf_payload_final)\n\n        # 5. \u7ec4\u88c5 Baseline \u6d41 (\u63d2\u5165 MPF)\n        primary_final = (\n            primary_bytes_raw[:2]\n            + primary_stub_segment\n            + mpf_segment_final\n            + primary_bytes_raw[2:]\n        )\n\n        # 6. \u62fc\u63a5\u5e76\u5199\u5165\u6587\u4ef6 (Baseline + Gainmap)\n        with open(filepath, \"wb\") as f:\n            f.write(primary_final)\n            f.write(gainmap_final)\n\n    except Exception as e:\n        raise RuntimeError(f\"Failed to write ISO 21496-1 file: {filepath}\") from e\n</code></pre>"},{"location":"api/io/#hdrconv.io.read_22028_pq","title":"<code>read_22028_pq(filepath)</code>","text":"<p>Read ISO 22028-5 PQ AVIF file.</p> <p>Decodes an AVIF file encoded with Perceptual Quantizer (PQ) transfer function as specified in ISO 22028-5 and SMPTE ST 2084.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to the PQ AVIF file.</p> required <p>Returns:</p> Type Description <code>HDRImage</code> <p>HDRImage dict containing:</p> <code>HDRImage</code> <ul> <li><code>data</code> (np.ndarray): PQ-encoded array, float32, shape (H, W, 3), range [0, 1] representing 0-10000 nits.</li> </ul> <code>HDRImage</code> <ul> <li><code>color_space</code> (str): Color primaries, typically 'bt2020'.</li> </ul> <code>HDRImage</code> <ul> <li><code>transfer_function</code> (str): Always 'pq'.</li> </ul> <code>HDRImage</code> <ul> <li><code>icc_profile</code> (bytes | None): Currently None (not extracted).</li> </ul> Note <p>Currently assumes BT.2020 color primaries and 10-bit decode range. Future versions may extract actual color metadata from AVIF.</p> See Also <ul> <li><code>write_22028_pq</code>: Write HDR image to PQ AVIF format.</li> <li><code>inverse_pq</code>: Convert PQ-encoded data to linear light.</li> </ul> Source code in <code>src/hdrconv/io/iso22028.py</code> <pre><code>def read_22028_pq(filepath: str) -&gt; HDRImage:\n    \"\"\"Read ISO 22028-5 PQ AVIF file.\n\n    Decodes an AVIF file encoded with Perceptual Quantizer (PQ) transfer\n    function as specified in ISO 22028-5 and SMPTE ST 2084.\n\n    Args:\n        filepath: Path to the PQ AVIF file.\n\n    Returns:\n        HDRImage dict containing:\n        - ``data`` (np.ndarray): PQ-encoded array, float32, shape (H, W, 3),\n            range [0, 1] representing 0-10000 nits.\n        - ``color_space`` (str): Color primaries, typically 'bt2020'.\n        - ``transfer_function`` (str): Always 'pq'.\n        - ``icc_profile`` (bytes | None): Currently None (not extracted).\n\n    Note:\n        Currently assumes BT.2020 color primaries and 10-bit decode range.\n        Future versions may extract actual color metadata from AVIF.\n\n    See Also:\n        - `write_22028_pq`: Write HDR image to PQ AVIF format.\n        - `inverse_pq`: Convert PQ-encoded data to linear light.\n    \"\"\"\n    with open(filepath, \"rb\") as f:\n        avif_bytes = f.read()\n    image_array = avif_decode(avif_bytes, numthreads=-1)\n    # Extract PQ-encoded array (normalized to [0, 1])\n    # Currently hard-coded to 10-bit decode range.\n    image_array = image_array / 1023.0\n    # TODO: Extract actual color primaries and transfer from AVIF metadata\n    # For now, assume BT.2020 PQ which is most common\n    return HDRImage(\n        data=image_array,\n        color_space=\"bt2020\",\n        transfer_function=\"pq\",\n        icc_profile=None,\n    )\n</code></pre>"},{"location":"api/io/#hdrconv.io.write_22028_pq","title":"<code>write_22028_pq(data, filepath)</code>","text":"<p>Write ISO 22028-5 PQ AVIF file.</p> <p>Encodes an HDR image to AVIF format with Perceptual Quantizer (PQ) transfer function as specified in ISO 22028-5 and SMPTE ST 2084.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>HDRImage</code> <p>HDRImage dict with PQ-encoded data. Must contain: - <code>data</code>: float32 array, shape (H, W, 3), range [0, 1]. - <code>color_space</code>: Color primaries ('bt709', 'p3', 'bt2020'). - <code>transfer_function</code>: Transfer function ('pq', 'hlg', etc.).</p> required <code>filepath</code> <code>str</code> <p>Output path for the AVIF file.</p> required Note <p>Output is encoded at 10-bit depth with quality level 90. Color primaries and transfer characteristics are embedded in AVIF metadata.</p> See Also <ul> <li><code>read_22028_pq</code>: Read PQ AVIF file.</li> <li><code>apply_pq</code>: Convert linear HDR to PQ-encoded values.</li> </ul> Source code in <code>src/hdrconv/io/iso22028.py</code> <pre><code>def write_22028_pq(data: HDRImage, filepath: str) -&gt; None:\n    \"\"\"Write ISO 22028-5 PQ AVIF file.\n\n    Encodes an HDR image to AVIF format with Perceptual Quantizer (PQ)\n    transfer function as specified in ISO 22028-5 and SMPTE ST 2084.\n\n    Args:\n        data: HDRImage dict with PQ-encoded data. Must contain:\n            - ``data``: float32 array, shape (H, W, 3), range [0, 1].\n            - ``color_space``: Color primaries ('bt709', 'p3', 'bt2020').\n            - ``transfer_function``: Transfer function ('pq', 'hlg', etc.).\n        filepath: Output path for the AVIF file.\n\n    Note:\n        Output is encoded at 10-bit depth with quality level 90.\n        Color primaries and transfer characteristics are embedded in AVIF metadata.\n\n    See Also:\n        - `read_22028_pq`: Read PQ AVIF file.\n        - `apply_pq`: Convert linear HDR to PQ-encoded values.\n    \"\"\"\n    # Map color primaries to numeric codes\n    primaries_map = {\"bt709\": 1, \"bt2020\": 9, \"p3\": 12}\n\n    # Map transfer characteristics to numeric codes\n    transfer_map = {\"bt709\": 1, \"linear\": 8, \"pq\": 16, \"hlg\": 18}\n\n    primaries_code = primaries_map.get(data[\"color_space\"], 9)\n    transfer_code = transfer_map.get(data[\"transfer_function\"], 16)\n\n    np_array = np.clip(data[\"data\"], 0, 1)\n    # scale to [0, 1023]\n    np_array = np_array * 1023.0\n    np_array = np_array.astype(np.uint16)\n\n    avif_bytes: bytes = avif_encode(\n        np_array,\n        level=90,\n        speed=8,\n        bitspersample=10,\n        primaries=primaries_code,\n        transfer=transfer_code,\n        numthreads=-1,\n    )\n\n    # Write the AVIF bytes to the output file\n    with open(filepath, \"wb\") as f:\n        f.write(avif_bytes)\n</code></pre>"},{"location":"api/io/#hdrconv.io.read_apple_heic","title":"<code>read_apple_heic(filepath)</code>","text":"<p>Read Apple HEIC HDR file with gain map.</p> <p>Extracts the base SDR image, HDR gain map, and headroom metadata from iPhone HEIC photos containing Apple's proprietary HDR format.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to the Apple HEIC file.</p> required <p>Returns:</p> Type Description <code>AppleHeicData</code> <p>AppleHeicData dict containing:</p> <code>AppleHeicData</code> <ul> <li><code>base</code> (np.ndarray): SDR image, uint8, shape (H, W, 3), Display P3.</li> </ul> <code>AppleHeicData</code> <ul> <li><code>gainmap</code> (np.ndarray): Gain map, uint8, shape (H, W, 1), 1/4 resolution.</li> </ul> <code>AppleHeicData</code> <ul> <li><code>headroom</code> (float): Peak luminance headroom, typically 2.0-8.0.</li> </ul> <p>Raises:</p> Type Description <code>ValueError</code> <p>If base image, gainmap, or headroom cannot be extracted.</p> Note <p>Requires exiftool to be installed and accessible in PATH for headroom extraction from EXIF/MakerNotes metadata.</p> See Also <ul> <li><code>apple_heic_to_hdr</code>: Convert AppleHeicData to linear HDR.</li> <li><code>has_gain_map</code>: Check if HEIC file contains gain map.</li> </ul> Source code in <code>src/hdrconv/io/apple_heic.py</code> <pre><code>def read_apple_heic(filepath: str) -&gt; AppleHeicData:\n    \"\"\"Read Apple HEIC HDR file with gain map.\n\n    Extracts the base SDR image, HDR gain map, and headroom metadata from\n    iPhone HEIC photos containing Apple's proprietary HDR format.\n\n    Args:\n        filepath: Path to the Apple HEIC file.\n\n    Returns:\n        AppleHeicData dict containing:\n        - ``base`` (np.ndarray): SDR image, uint8, shape (H, W, 3), Display P3.\n        - ``gainmap`` (np.ndarray): Gain map, uint8, shape (H, W, 1), 1/4 resolution.\n        - ``headroom`` (float): Peak luminance headroom, typically 2.0-8.0.\n\n    Raises:\n        ValueError: If base image, gainmap, or headroom cannot be extracted.\n\n    Note:\n        Requires exiftool to be installed and accessible in PATH for\n        headroom extraction from EXIF/MakerNotes metadata.\n\n    See Also:\n        - `apple_heic_to_hdr`: Convert AppleHeicData to linear HDR.\n        - `has_gain_map`: Check if HEIC file contains gain map.\n    \"\"\"\n\n    base, gainmap = read_base_and_gain_map(filepath)\n    headroom = get_headroom(filepath)\n\n    if base is None or gainmap is None or headroom is None:\n        raise ValueError(f\"Failed to read Apple HEIC data from {filepath}\")\n\n    return AppleHeicData(base=base, gainmap=gainmap, headroom=headroom)\n</code></pre>"},{"location":"api/io/#hdrconv.io.read_ios_hdr_screenshot","title":"<code>read_ios_hdr_screenshot(filepath, grid_cols=None, grid_rows=None, tile_size=512, real_width=None, real_height=None)</code>","text":"<p>Read iOS HDR screenshot HEIC file.</p> <p>Extracts the main image, gainmap, and metadata from iOS HDR screenshots and returns a standard GainmapImage structure suitable for use with <code>gainmap_to_hdr</code>.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to the iOS HDR screenshot HEIC file.</p> required <code>grid_cols</code> <code>Optional[int]</code> <p>Number of tile columns (auto-detected if None).</p> <code>None</code> <code>grid_rows</code> <code>Optional[int]</code> <p>Number of tile rows (auto-detected if None).</p> <code>None</code> <code>tile_size</code> <code>int</code> <p>Size of each square tile in pixels. Default: 512.</p> <code>512</code> <code>real_width</code> <code>Optional[int]</code> <p>Actual image width (auto-detected if None).</p> <code>None</code> <code>real_height</code> <code>Optional[int]</code> <p>Actual image height (auto-detected if None).</p> <code>None</code> <p>Returns:</p> Type Description <code>GainmapImage</code> <p>GainmapImage dict containing:</p> <code>GainmapImage</code> <ul> <li><code>baseline</code> (np.ndarray): Main image, uint8, shape (H, W, 3), Display P3.</li> </ul> <code>GainmapImage</code> <ul> <li><code>gainmap</code> (np.ndarray): Gain map, uint8, shape (H, W, 3), three-channel.</li> </ul> <code>GainmapImage</code> <ul> <li><code>metadata</code> (GainmapMetadata): Contains gainmap_max, offset values.</li> </ul> <code>GainmapImage</code> <ul> <li><code>baseline_icc</code> (bytes | None): None.</li> </ul> <code>GainmapImage</code> <ul> <li><code>gainmap_icc</code> (bytes | None): None.</li> </ul> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If external tools (MP4Box, ffmpeg) are not available.</p> <code>ValueError</code> <p>If the file cannot be parsed or is not a valid iOS HDR screenshot.</p> <code>FileNotFoundError</code> <p>If the input file does not exist.</p> Note <p>Requires MP4Box (from GPAC) and ffmpeg to be installed and available in PATH.</p> <p>The gainmap_min is always 0 and gainmap_gamma is always 1 for iOS HDR screenshots. Both baseline_offset and alternate_offset are set to the same value extracted from the tmap metadata.</p> See Also <ul> <li><code>gainmap_to_hdr</code>: Convert the returned GainmapImage to linear HDR.</li> </ul> Source code in <code>src/hdrconv/io/ios_hdr_screenshot.py</code> <pre><code>def read_ios_hdr_screenshot(\n    filepath: str,\n    grid_cols: Optional[int] = None,\n    grid_rows: Optional[int] = None,\n    tile_size: int = 512,\n    real_width: Optional[int] = None,\n    real_height: Optional[int] = None,\n) -&gt; GainmapImage:\n    \"\"\"Read iOS HDR screenshot HEIC file.\n\n    Extracts the main image, gainmap, and metadata from iOS HDR screenshots\n    and returns a standard GainmapImage structure suitable for use with\n    `gainmap_to_hdr`.\n\n    Args:\n        filepath: Path to the iOS HDR screenshot HEIC file.\n        grid_cols: Number of tile columns (auto-detected if None).\n        grid_rows: Number of tile rows (auto-detected if None).\n        tile_size: Size of each square tile in pixels. Default: 512.\n        real_width: Actual image width (auto-detected if None).\n        real_height: Actual image height (auto-detected if None).\n\n    Returns:\n        GainmapImage dict containing:\n        - ``baseline`` (np.ndarray): Main image, uint8, shape (H, W, 3), Display P3.\n        - ``gainmap`` (np.ndarray): Gain map, uint8, shape (H, W, 3), three-channel.\n        - ``metadata`` (GainmapMetadata): Contains gainmap_max, offset values.\n        - ``baseline_icc`` (bytes | None): None.\n        - ``gainmap_icc`` (bytes | None): None.\n\n    Raises:\n        RuntimeError: If external tools (MP4Box, ffmpeg) are not available.\n        ValueError: If the file cannot be parsed or is not a valid iOS HDR screenshot.\n        FileNotFoundError: If the input file does not exist.\n\n    Note:\n        Requires MP4Box (from GPAC) and ffmpeg to be installed and available in PATH.\n\n        The gainmap_min is always 0 and gainmap_gamma is always 1 for iOS HDR screenshots.\n        Both baseline_offset and alternate_offset are set to the same value extracted\n        from the tmap metadata.\n\n    See Also:\n        - `gainmap_to_hdr`: Convert the returned GainmapImage to linear HDR.\n    \"\"\"\n    # Check dependencies\n    available, missing = _check_dependencies()\n    if not available:\n        raise RuntimeError(\n            f\"Missing required external tools: {', '.join(missing)}. \"\n            \"Please install them and ensure they are in PATH.\"\n        )\n\n    if not os.path.exists(filepath):\n        raise FileNotFoundError(f\"File not found: {filepath}\")\n\n    # Create temp directory for processing\n    temp_dir = tempfile.mkdtemp(prefix=\"ios_hdr_\")\n\n    try:\n        # Get all hvc1 IDs\n        all_ids = _get_hvc1_ids(filepath)\n        if not all_ids:\n            raise ValueError(\"No hvc1 streams found in file\")\n\n        # Split into groups (main image and gainmap)\n        groups = _split_ids_into_groups(all_ids)\n        if len(groups) &lt; 2:\n            raise ValueError(\n                \"Expected at least 2 image groups (main + gainmap), \"\n                f\"found {len(groups)}\"\n            )\n\n        main_ids = groups[0]\n        gainmap_ids = groups[1]\n\n        # Auto-detect grid parameters if not provided\n        if grid_cols is None or grid_rows is None:\n            # Extract first tile to detect size\n            first_id = main_ids[0]\n            raw_path = os.path.join(temp_dir, f\"{first_id}.hvc\")\n            jpg_path = os.path.join(temp_dir, \"first_tile.jpg\")\n\n            param = f\"{first_id}:path={raw_path}\"\n            subprocess.run(\n                [\"MP4Box\", \"-dump-item\", param, filepath],\n                stdout=subprocess.DEVNULL,\n                stderr=subprocess.DEVNULL,\n            )\n            subprocess.run(\n                [\"ffmpeg\", \"-y\", \"-i\", raw_path, \"-q:v\", \"2\", jpg_path],\n                stdout=subprocess.DEVNULL,\n                stderr=subprocess.DEVNULL,\n            )\n\n            detected_cols, detected_rows, detected_tile_size = _detect_grid_parameters(\n                len(main_ids), jpg_path\n            )\n            grid_cols = grid_cols or detected_cols\n            grid_rows = grid_rows or detected_rows\n            tile_size = detected_tile_size\n\n            # Clean up detection files\n            if os.path.exists(raw_path):\n                os.remove(raw_path)\n            if os.path.exists(jpg_path):\n                os.remove(jpg_path)\n\n        # Get original resolution from HEIC metadata if not provided\n        if real_width is None or real_height is None:\n            orig_width, orig_height = _get_original_resolution(filepath)\n            real_width = real_width or orig_width\n            real_height = real_height or orig_height\n\n        # Process main image\n        main_temp = os.path.join(temp_dir, \"main\")\n        os.makedirs(main_temp, exist_ok=True)\n        main_image = _process_tile_group(\n            main_ids,\n            filepath,\n            main_temp,\n            grid_cols,\n            grid_rows,\n            tile_size,\n            real_width or canvas_w,\n            real_height or canvas_h,\n        )\n\n        # Process gainmap\n        gainmap_temp = os.path.join(temp_dir, \"gainmap\")\n        os.makedirs(gainmap_temp, exist_ok=True)\n        gainmap_image = _process_tile_group(\n            gainmap_ids,\n            filepath,\n            gainmap_temp,\n            grid_cols,\n            grid_rows,\n            tile_size,\n            real_width or canvas_w,\n            real_height or canvas_h,\n        )\n\n        # Parse tmap metadata\n        tmap_data = _dump_tmap_bytes(filepath, temp_dir)\n        if tmap_data is None:\n            raise ValueError(\"No tmap metadata found in file\")\n\n        gainmapmax, offset = _parse_gainmapmax_offset_from_tmap(tmap_data)\n\n        # Construct GainmapMetadata\n        # iOS HDR screenshots use: gainmap_min=0, gamma=1, both offsets equal\n        metadata = GainmapMetadata(\n            minimum_version=0,\n            writer_version=0,\n            baseline_hdr_headroom=1.0,\n            alternate_hdr_headroom=float(2**gainmapmax),\n            is_multichannel=True,\n            use_base_colour_space=True,\n            gainmap_min=(0.0, 0.0, 0.0),\n            gainmap_max=(gainmapmax, gainmapmax, gainmapmax),\n            gainmap_gamma=(1.0, 1.0, 1.0),\n            baseline_offset=(offset, offset, offset),\n            alternate_offset=(offset, offset, offset),\n        )\n\n        # Ensure arrays are uint8\n        if main_image.dtype != np.uint8:\n            main_image = main_image.astype(np.uint8)\n        if gainmap_image.dtype != np.uint8:\n            gainmap_image = gainmap_image.astype(np.uint8)\n\n        return GainmapImage(\n            baseline=main_image,\n            gainmap=gainmap_image,\n            metadata=metadata,\n            baseline_icc=None,\n            gainmap_icc=None,\n        )\n\n    finally:\n        # Clean up temp directory\n        shutil.rmtree(temp_dir, ignore_errors=True)\n</code></pre>"},{"location":"api/io/#hdrconv.io.read_ultrahdr","title":"<code>read_ultrahdr(filepath)</code>","text":"<p>Read UltraHDR JPEG file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to the UltraHDR JPEG file.</p> required <p>Returns:</p> Type Description <code>GainmapImage</code> <p>GainmapImage dict containing baseline, gainmap, metadata, and ICC data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If gainmap stream or HDR gainmap metadata is missing.</p> Source code in <code>src/hdrconv/io/ultrahdr.py</code> <pre><code>def read_ultrahdr(filepath: str) -&gt; GainmapImage:\n    \"\"\"Read UltraHDR JPEG file.\n\n    Args:\n        filepath: Path to the UltraHDR JPEG file.\n\n    Returns:\n        GainmapImage dict containing baseline, gainmap, metadata, and ICC data.\n\n    Raises:\n        ValueError: If gainmap stream or HDR gainmap metadata is missing.\n    \"\"\"\n    with open(filepath, \"rb\") as f:\n        raw_data = f.read()\n\n    primary_data, gainmap_data = _split_mpf_container(raw_data)\n\n    # Fallback: split by EOI+SOI if MPF is missing\n    if not gainmap_data:\n        separator = b\"\\xff\\xd9\\xff\\xd8\"\n        split_pos = raw_data.find(separator)\n        if split_pos != -1:\n            primary_data = raw_data[: split_pos + 2]\n            gainmap_data = raw_data[split_pos + 2 :]\n\n    if not gainmap_data:\n        raise ValueError(\"No gainmap found in container (MPF missing or invalid).\")\n\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\n            \"ignore\",\n            message=\"Image appears to be a malformed MPO file\",\n            category=UserWarning,\n        )\n        base_img = Image.open(io.BytesIO(primary_data)).convert(\"RGB\")\n        gain_img = Image.open(io.BytesIO(gainmap_data)).convert(\"RGB\")\n\n    base_arr = np.array(base_img)\n    gain_arr = np.array(gain_img)\n\n    base_segments = list(_yield_jpeg_segments(primary_data))\n    gain_segments = list(_yield_jpeg_segments(gainmap_data))\n\n    base_icc = _extract_icc(base_segments)\n    gain_icc = _extract_icc(gain_segments)\n\n    hdrgm_meta = None\n\n    # Prefer gainmap stream\n    for segments in [gain_segments, base_segments]:\n        for code, payload in segments:\n            if code == APP1:\n                xmp_xml = _extract_xmp_payload(payload)\n                if not xmp_xml:\n                    continue\n                parsed = _parse_hdrgm_metadata(xmp_xml)\n                if parsed and (\"GainMapMin\" in parsed or \"Version\" in parsed):\n                    hdrgm_meta = parsed\n                    break\n        if hdrgm_meta:\n            break\n\n    if not hdrgm_meta:\n        raise ValueError(\"UltraHDR gainmap metadata (XMP) not found.\")\n\n    metadata = _hdrgm_to_gainmap_metadata(hdrgm_meta, gain_arr)\n\n    return GainmapImage(\n        baseline=base_arr,\n        gainmap=gain_arr,\n        metadata=metadata,\n        baseline_icc=base_icc,\n        gainmap_icc=gain_icc,\n    )\n</code></pre>"},{"location":"api/io/#hdrconv.io.write_ultrahdr","title":"<code>write_ultrahdr(data, filepath)</code>","text":"<p>Write UltraHDR JPEG file.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>GainmapImage</code> <p>GainmapImage dict containing baseline, gainmap, and metadata.</p> required <code>filepath</code> <code>str</code> <p>Output path for the JPEG file.</p> required Source code in <code>src/hdrconv/io/ultrahdr.py</code> <pre><code>def write_ultrahdr(data: GainmapImage, filepath: str) -&gt; None:\n    \"\"\"Write UltraHDR JPEG file.\n\n    Args:\n        data: GainmapImage dict containing baseline, gainmap, and metadata.\n        filepath: Output path for the JPEG file.\n    \"\"\"\n    try:\n        gainmap_bytes_raw = _create_jpeg_bytes(data[\"gainmap\"], data.get(\"gainmap_icc\"))\n\n        # Insert minimal MPF APP2 in gainmap stream for compatibility\n        gainmap_mpf_segment = _build_app2_segment(_build_mpf_minimal_payload(2))\n\n        xmp_payload = _build_hdrgm_xmp(data[\"metadata\"])\n        xmp_segment = _build_app1_segment(xmp_payload)\n\n        gainmap_final = (\n            gainmap_bytes_raw[:2]\n            + gainmap_mpf_segment\n            + xmp_segment\n            + gainmap_bytes_raw[2:]\n        )\n\n        primary_bytes_raw = _create_jpeg_bytes(\n            data[\"baseline\"], data.get(\"baseline_icc\")\n        )\n\n        gcontainer_payload = _build_gcontainer_xmp(len(gainmap_final))\n        gcontainer_segment = _build_app1_segment(gcontainer_payload)\n\n        mpf_payload_temp = _build_mpf_payload(\n            primary_size=len(primary_bytes_raw),\n            gainmap_size=len(gainmap_final),\n            gainmap_offset=0,\n        )\n        mpf_segment_temp = _build_app2_segment(mpf_payload_temp)\n\n        total_primary_len = (\n            len(primary_bytes_raw) + len(gcontainer_segment) + len(mpf_segment_temp)\n        )\n\n        mpf_marker_offset = 2 + len(gcontainer_segment)\n        mpf_base_file_offset = mpf_marker_offset + 8\n        gainmap_relative_offset = total_primary_len - mpf_base_file_offset\n\n        mpf_payload_final = _build_mpf_payload(\n            primary_size=total_primary_len,\n            gainmap_size=len(gainmap_final),\n            gainmap_offset=gainmap_relative_offset,\n        )\n        mpf_segment_final = _build_app2_segment(mpf_payload_final)\n\n        primary_final = (\n            primary_bytes_raw[:2]\n            + gcontainer_segment\n            + mpf_segment_final\n            + primary_bytes_raw[2:]\n        )\n\n        with open(filepath, \"wb\") as f:\n            f.write(primary_final)\n            f.write(gainmap_final)\n\n    except Exception as e:\n        raise RuntimeError(f\"Failed to write UltraHDR file: {filepath}\") from e\n</code></pre>"}]}